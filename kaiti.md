[TOC]



#1 为什么要使用纠删码
随着大数据时代的来临,互联网和科学研究领域产生了大量的数据,这些数据惊人的数据都需要保存到存储设备上.
同时,为了保证数据的可靠性,需要使用某种数据可靠性的技术.
Google2004年发表了他们使用的分布式文件系统GFS的论文[GFS],说明了他们使用的系统的一些情况,其中使用的保证数据可靠性的方法是使用三副本,即每个文件在三个不同的节点存储三份,其中两份当做备份,这样当
在相同可靠性的情况下,存储开销更小.

系统|可靠性方法| 存储开销
:--: |:--: |:--: 
GFS|三副本|200%
GFS2|RS(6, 3)|100%
Hadoop|RS(10, 6)|66.7%


#2 纠删码原理


##2.1 Galois Field 伽罗瓦域
###伽罗瓦域的定义
非空集合R, 以及R上面的两个二元运算+， *。 <R, +, *> 构成域， 当满足下面的三个条件时：
1、<R, +>构成可交换群
2、<R\{0}, *> 构成可交换群
3、* 对 + 满足分配率， 即 $ \forall a, b, c \in R, s.t. (a+b)*c = a*b + a*c $

非空集合R，以及R上的一个二元运算*构成的代数结构 <R, *> 称为可交换群，当满足下面的五个条件时
1、*运算满足封闭性，即  $ \forall a, b \in R, a*b \in R $
2、*运算满足结合性，即 $ \forall a, b, c \in R， (a*b)*c = a*(b*c)$
3、存在单位元，即 $ \exists e \in R, s.t. \forall a \in R, e*a =a*e=e$
4、每个元素都有逆元素，即 $ \forall a \in R, \exists b \in R, s.t. a * b =b*a =e $
5、*运算满足交换律，即 $ \forall a, b \in R, a*b=b*a$

当集合R中的元素的个数为有限个时，域<R, +, *> 称为有限域 Finite Field, 也称为Galois Field GF。

###伽罗瓦域中的元素
Galois Field, ，记为 $GF(2^w)$，其中 $ w $  为位的宽度，我们在这里为了演示的方便，令 $ w  = 4$ .
伽罗瓦域 $GF(2^w) $ 中有 $2^w$个元素 ，元素的 值为 $0, 1, ..., 2^w-1$。 
我们将$x$的多项式与二进制数一一对应起来,对应规则很简单,$x$ 的多项式 中的每一项 $x^i$, $i = 0, 1, 2 \dots $, 若项的系数为1,则在该多项式对应的二进制数中对应的位置为1,否则为0(二进制最右边为第0位)。
例如, $x^3+x^2+1$, 对应二进制为 1101,即十进制数字13.
我们下面令$w=4$, 并取原始多项式 $q(x)= x^4+x+1$,该多项式对应的二进制数为 10011。

从 $ x^0 $ 开始,然后将序列的最后一个多项式乘以 $ x $ , 然后再 模 $ q(x) $.
下面的表格说明了生成序列的过程。

指数表示 | 多项式表示 | 二进制表示 | 十进制表示
---| ----|:---:|:---:
$ 0 $ | $ 0 $ | 0000 | 0
$ x^0 $ | $ x^0 = 1$ | 0001 |1
$ x^1 $ | $ 1 \cdot x = x $ | 0010 |2
$ x^2 $ | $ x \cdot x = x^2 $ | 0100 |4
$ x^3 $ | $ x^2 \cdot x = x^3 $ | 1000 |8
$ x^4 $ | $ x^3 \cdot x = x^4 \  mod \   q(x) =x+1$ | 0011 |3
$ x^5 $ | $ (x+1) \cdot x = x^2+x $ | 0110 |6
$ x^6 $ | $ (x^2+x) \cdot x = x^3+x^2 $ | 1100 |12
$ x^7 $ | $ (x^3+x^2) \cdot x = x^4+x^3 \  mod \  q(x) = x^3+x+1$ | 1011 |11
$ x^8 $ | $ (x^3+x+1) \cdot x = x^4+x^2+x \  mod \  q(x) = x^2+1$ | 0101 |5
$ x^9 $ | $ (x^2+1) \cdot x = x^3+x $ | 1010 | 10
$ x^{10} $ | $ (x^3+x) \cdot x = x^4+x^2 \  mod \  q(x) = x^2+x+1 $ | 0111 | 7
$ x^{11} $ | $ (x^2+x+1) \cdot x = x^3+x^2+x $ | 1110 | 14
$ x^{12} $ | $ (x^3+x^2+x) \cdot x = x^4+x^3+x^2 \  mod \  q(x) = x^3+x^2+x+1 $ | 1111 | 15
$ x^{13} $ | $ (x^3+x^2+x+1) \cdot x = x^4+x^3+x^2+x \  mod \  q(x) = x^3+x^2+1 $ | 1101 | 13
$ x^{14} $ | $ (x^3+x^2+1) \cdot x = x^4+x^3+x \  mod \  q(x) = x^3+1 $ | 1001 | 9
$ x^{15} $ | $ (x^3+1) \cdot x = x^4+x \  mod \  q(x) = 1 $ | 0001 | 1

伽罗瓦域中的两个元素的加法和减法等价于 他们的对应多项式做多项式加法和减法。

$$ 12 + 5 = 1100 + 0101 = ( x^3 + x^2) + (x^2 + 1) = x^3+1 = 1001 = 9 $$

$$ 12 - 5 =  1100 -  0101 = ( x^3 + x^2) -  (x^2 + 1) = x^3+1 = 1001 = 9 $$

可以看出伽罗瓦域中的两个元素的加法和减法等价于 他们的异或XOR。
即

$$ 12 + 5 = 1100 \oplus  0101 = 1001 = 9 $$

$$ 12 - 5 = 1100 \oplus  0101 = 1001 = 9 $$


伽罗瓦域上面的乘法计算比较复杂，需要将两个元素都转为它们对应的多项式，然后进行多项式的乘法，再模上他们的产生式多项式，最后再将多项式结果转回数值。

如
$$ 7 \times 3 = 0111 \times 0011 = ( x^2 + x + 1) ( x + 1) = x^3 + 1  = 1001 = 9 $$

可以看出伽罗瓦域上面的乘法计算开销比较大。

因为当 $ w $ 比较小时， 伽罗瓦域内的元素很少，因此我们可以通过表格将一部分计算结果保存起来，在计算伽罗瓦域上面的两个元素的乘法时，可以直接采用查表的方式获得已计算好的数据，简化我们的计算。

###  利用对数表和指数表简化伽罗瓦域上的乘法计算

我们可以构造两个表， 对数表 $ gflog $ 和指数表 $ gfexp$, 然后将伽罗瓦域上面的两个元素的乘法转换为下面的计算方法。

$$  a \times b = gfexp[ ( gflog[a] + gflog[b]  ) mod (2^w - 1) ] $$

$$  a \div  b = gfexp[ ( gflog[a] - gflog[b]  ) mod (2^w - 1) ] $$

这样就将伽罗瓦域上面的两个元素的乘法转换为了三次查表操作，一次模加法操作。

生成对数表 $ gflog $  和 指数表 $ gfexp $ 的方法如下面代码所示:

``` c
unsigned char gflog[16], gfexp[16];
void gen_tables()
{
    unsigned char b, log;
    b = 1;
    for (log = 0; log < 16-1; ++log) {
        gflog[b] = log;
        gfexp[log] =  b;
        b = b << 1;
        if (b >= 16) b = b ^ 023;
    }
}
```
其中 八进制数 023 = 10011是 原始多项式 $q(x) = x^4 + x +1 $ 对应的数字。

例如，使用上面的代码为 $w=4$生成如下的对数和指数两个表:

t       | 0 |1 |2 |3 |4 |5 |6 |7 |8 |9 |10 |11 |12 |13 |14 |15 
:----:  |:-: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: 
gflog[t]  | - |0 |1 |4 |2 |8 |5 |10 |3 |14 |9 |7 |6 |13 |11 |12 
gfexp[t] | 1 |2 |4 |8 |3 |6 |12 |11 |5 |10 |7 |14 |15 |13 |9 |- 

利用上面的两个表计算伽罗瓦域上面的两个元素的乘法和除法，代码如下：

```c
unsigned char gflog[16], gfexp[16];
unsigned char mult(unsigned char a, unsigned char b)
{
    if (a == 0 || b == 0) 
        return 0;
    unsigned char sum_log = ( gflog[a] + gflog[b] ) % 15;
    return gfexp[sum_log];
}
```

例子如下：

$$ 12 \times 5 = gfexp[(  gflog[12] + gflog[5] ) mod( 2^4 - 1)] = gfexp[(  6 + 8 ) mod 15] = gfexp[14] = 9$$

$$ 12 \div 5 = gfexp[(  gflog[12] - gflog[5] ) mod( 2^4 - 1)] = gfexp[(  6 - 8 ) mod 15] = gfexp[13] = 13 $$  

$$ 9 \times 7 = gfexp[(  gflog[9] + gflog[7] ) mod( 2^4 - 1)] = gfexp[(  14 + 10 ) mod 15] = gfexp[9] = 10$$

$$ 9 \div 7 = gfexp[(  gflog[9] - gflog[7] ) mod( 2^4 - 1)] = gfexp[(  14 - 10 ) mod 15] = gfexp[4] = 3$$

从上面可以看出每次计算乘法都需要计算一次模运算，因此我们下面将模运算消去。
伽罗瓦域 $ GF(2^4) $ 上面的任意两个元素 $ a，b \in [0, 15]$ , 那么计算他们的乘积首先需要需要计算它们的对数的和. 因为 $ log(a) \in [0, 14] $ , 所以 $ log(a) + log(b) \in [0, 28] $, 所以我们将指数表扩展为有29个元素的表，让超过14的位置的值为 该位置减去15位置的值，即 对于 $ x \geq 15, exp[x] = exp[x - 15] $ .

这样我们得到下面的指数表。

t       | 0 |1 |2 |3 |4 |5 |6 |7 |8 |9 |10 |11 |12 |13 |14  |
:----:  |:-: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: 
gfexp[t] | 1 |2 |4 |8 |3 |6 |12 |11 |5 |10 |7 |14 |15 |13 |9 
t | 15	|16|	17|	18	|19	|20	|21|	22	|23	|24|	25	|26	|27	|28
gfexp[t] | 1 |2 |4 |8 |3 |6 |12 |11 |5 |10 |7 |14 |15 |13 

代码如下：

```c
unsigned char gflog[16], gfexp[29];
unsigned char mult(unsigned char a, unsigned char b)
{
    if (a == 0 || b == 0) 
        return 0;
    unsigned char sum_log = gflog[a] + gflog[b];
    return gfexp[sum_log];
}
```

例子如下：
$$ 9 \times 7 = gfexp[ gflog[9] + gflog[7] ] = gfexp[ 14 + 10  ] = gfexp[24] = 10 $$


我们再观察发现伽罗瓦域计算上面的两个数的乘法时， 还有一个条件语句，我们通过再一次扩展指数表， 消去条件语句。

通过归纳我们可以得出

$$ \begin{cases}
a = 0 , b \in [1, 15], 这时 log[a] \in [0, 14]; \\
b = 0 , a \in [1, 15], 这时 log[b] \in [0, 14];  \\
a = 0 时， b = 0 ;
\end{cases}  $$

因为上一步将指数表扩展为了29个元素.我们可以进一步扩展它来计算a与b中至少有一个为0的乘积.
因为一开始的对数表中0的对数未定义, 我们可以定义 log[0] = 29, 这时我们将 $ exp[29 - 42] $ 定义为0, 即可通过一次查表将a b中只有一个0时的乘积计算出来.
我们再考虑a与b都为0时,因为我们已经定义了 $ log[0] = 29 $ , 所以这时$ log[a]+log[b]=log[0]+log[0]=58 $ , 我们需要将$ exp[58] $ 定义为0. 指数表中的 $ exp[43 - 57] $ 不会用到，可以为任意值。


t       | 0 |1 |2 |3 |4 |5 |6 |7 |8 |9 |10 |11 |12 |13 |14 |15 
:----:  |:-: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: 
gflog[t]  | 29 |0 |1 |4 |2 |8 |5 |10 |3 |14 |9 |7 |6 |13 |11 |12 

t       | 0 |1 |2 |3 |4 |5 |6 |7 |8 |9 |10 |11 |12 |13 |14  |
:----:  |:-: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: |:--: 
gfexp[t] | 1 |2 |4 |8 |3 |6 |12 |11 |5 |10 |7 |14 |15 |13 |9 
t | 15	|16|	17|	18	|19	|20	|21|	22	|23	|24|	25	|26	|27	|28
gfexp[t] | 1 |2 |4 |8 |3 |6 |12 |11 |5 |10 |7 |14 |15 |13 
t | 29	|30|	31|	32	|33	|34	|35|36	|37	|38|	39	|40	|41	|42 |43
gfexp[t] |0  |0  |0  |0  |0  |0  |0  |0  |0  |0  |0  |0  |0  |0  |0  
t | 44	|45|46|47|48 |49	|50|51	|52	|53|54|55|56|57|58
gfexp[t] |   |   |   |   |   |   |   |   |   |   |   |   |   |   |0

这时计算伽罗瓦域上面的任意两个数的乘法都只需要三次查表操作。

```c
unsigned char gflog[16], gfexp[59];
unsigned char mult(unsigned char a, unsigned char b)
{
    unsigned char sum_log = gflog[a] + gflog[b];
    return gfexp[sum_log];
}
```

$$ 9 \times 7 = gfexp[ gflog[9] + gflog[7] ] = gfexp[ 14 + 10 ] = gfexp[24] = 10 $$

$$ 9 \times 0 = gfexp[ gflog[9] + gflog[0] ] = gfexp[ 14 + 29 ] = gfexp[43] = 0 $$

$$ 0 \times 7 = gfexp[ gflog[0] + gflog[7] ] = gfexp[ 29 + 10 ] = gfexp[39] = 0 $$

$$ 0 \times 0 = gfexp[ gflog[0] + gflog[0] ] = gfexp[ 29 + 29 ] = gfexp[58] = 0 $$

### 利用乘法表计算伽罗瓦域上面的乘法
令$w=4$, 这时伽罗瓦域内只有 $2^4 = 16$个元素 $0, 1, \dots , 15$, 我们可以生成一个 $ 16 \times 16$ 的乘法表 gfmul, 其中的元素都是提前计算好的伽罗瓦域内的任意两个元素的乘积,如下表所示。
这时我们可以将计算伽罗瓦域内的两个元素的乘积简化为一次查表操作 

$$ a \times b = gfmul[a][b] $$

a\b |  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 | 10 | 11 | 12 | 13 | 14 | 15 
--- |----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----
  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 
  1 |  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 | 10 | 11 | 12 | 13 | 14 | 15 
  2 |  0 |  2 |  4 |  6 |  8 | 10 | 12 | 14 |  3 |  1 |  7 |  5 | 11 |  9 | 15 | 13 
  3 |  0 |  3 |  6 |  5 | 12 | 15 | 10 |  9 | 11 |  8 | 13 | 14 |  7 |  4 |  1 |  2 
  4 |  0 |  4 |  8 | 12 |  3 |  7 | 11 | 15 |  6 |  2 | 14 | 10 |  5 |  1 | 13 |  9 
  5 |  0 |  5 | 10 | 15 |  7 |  2 | 13 |  8 | 14 | 11 |  4 |  1 |  9 | 12 |  3 |  6 
  6 |  0 |  6 | 12 | 10 | 11 | 13 |  7 |  1 |  5 |  3 |  9 | 15 | 14 |  8 |  2 |  4 
  7 |  0 |  7 | 14 |  9 | 15 |  8 |  1 |  6 | 13 | 10 |  3 |  4 |  2 |  5 | 12 | 11 
  8 |  0 |  8 |  3 | 11 |  6 | 14 |  5 | 13 | 12 |  4 | 15 |  7 | 10 |  2 |  9 |  1 
  9 |  0 |  9 |  1 |  8 |  2 | 11 |  3 | 10 |  4 | 13 |  5 | 12 |  6 | 15 |  7 | 14 
 10 |  0 | 10 |  7 | 13 | 14 |  4 |  9 |  3 | 15 |  5 |  8 |  2 |  1 | 11 |  6 | 12 
 11 |  0 | 11 |  5 | 14 | 10 |  1 | 15 |  4 |  7 | 12 |  2 |  9 | 13 |  6 |  8 |  3 
 12 |  0 | 12 | 11 |  7 |  5 |  9 | 14 |  2 | 10 |  6 |  1 | 13 | 15 |  3 |  4 |  8 
 13 |  0 | 13 |  9 |  4 |  1 | 12 |  8 |  5 |  2 | 15 | 11 |  6 |  3 | 14 | 10 |  7 
 14 |  0 | 14 | 15 |  1 | 13 |  3 |  2 | 12 |  9 |  7 |  6 |  8 |  4 | 10 | 11 |  5 
 15 |  0 | 15 | 13 |  2 |  9 |  6 |  4 | 11 |  1 | 14 | 12 |  3 |  8 |  7 |  5 | 10 

上表的十六进制表示,为了下面描述CPU加速的方便.

a\b| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | a | b | c | d | e | f 
---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---
 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 
 1 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | a | b | c | d | e | f 
 2 | 0 | 2 | 4 | 6 | 8 | a | c | e | 3 | 1 | 7 | 5 | b | 9 | f | d 
 3 | 0 | 3 | 6 | 5 | c | f | a | 9 | b | 8 | d | e | 7 | 4 | 1 | 2 
 4 | 0 | 4 | 8 | c | 3 | 7 | b | f | 6 | 2 | e | a | 5 | 1 | d | 9 
 5 | 0 | 5 | a | f | 7 | 2 | d | 8 | e | b | 4 | 1 | 9 | c | 3 | 6 
 6 | 0 | 6 | c | a | b | d | 7 | 1 | 5 | 3 | 9 | f | e | 8 | 2 | 4 
 7 | 0 | 7 | e | 9 | f | 8 | 1 | 6 | d | a | 3 | 4 | 2 | 5 | c | b 
 8 | 0 | 8 | 3 | b | 6 | e | 5 | d | c | 4 | f | 7 | a | 2 | 9 | 1 
 9 | 0 | 9 | 1 | 8 | 2 | b | 3 | a | 4 | d | 5 | c | 6 | f | 7 | e 
 a | 0 | a | 7 | d | e | 4 | 9 | 3 | f | 5 | 8 | 2 | 1 | b | 6 | c 
 b | 0 | b | 5 | e | a | 1 | f | 4 | 7 | c | 2 | 9 | d | 6 | 8 | 3 
 c | 0 | c | b | 7 | 5 | 9 | e | 2 | a | 6 | 1 | d | f | 3 | 4 | 8 
 d | 0 | d | 9 | 4 | 1 | c | 8 | 5 | 2 | f | b | 6 | 3 | e | a | 7 
 e | 0 | e | f | 1 | d | 3 | 2 | c | 9 | 7 | 6 | 8 | 4 | a | b | 5 
 f | 0 | f | d | 2 | 9 | 6 | 4 | b | 1 | e | c | 3 | 8 | 7 | 5 | a 
 
利用乘法表计算伽罗瓦域上面的两个元素的代码如下

```c
unsigned char gfmul[16][16];
unsigned char _mult(unsigned char a, unsigned char b)
{
    return gfmul[a][b];
}
```

利用乘法表计算上节的例子如下

$$ 12 \ times 5 = gfmul[12][5] = 9  $$

$$ 9  \ times 7 = gfmul[9][7] = 10 $$ 

##2.2 Reed-Solomon 纠删码编码

给定一个文件 $D$ ，我们将该文件分为相同大小的 $k$  个数据块，分为记为 $d_1, d_2, \dots , d_k $ ,我们简记为 $ D = [d_1, d_2, \dots , d_k] ^T $.
然后我们设 $GF(2^w)$ 中的 $w$ 为 $8$ , 其中 $m + k \leq 2^w $
在假设我们需要生成额外的 $m$ 个编码块 $ c_1, c_2, \dots   , c_m$ , 同样我们简记为 $C = [c_1, c_2,   \dots  , c_m] ^ T$ ，这些编码块的大小和数据块的大小相同。

我们首先需要生成一个 $ m \times k $ 大小的编码矩阵 $ V _{ m \times k}$，然后用如下公式计算编码块

$$ C= V D  \tag{1} $$

其中乘法是伽罗瓦域上的乘。

将其展开

$$
\left  [ 
\begin {matrix} 
v_{11} &  v_{12} & \ldots & v_{1k} \\
v_{21} &  v_{22} & \ldots & v_{2k} \\
\vdots & \vdots & \ddots & \vdots\\
v_{m1} &  v_{m2} & \ldots & v_{mk} 
\end{matrix}  \right  ] 
\times
\left [  \begin{matrix} d_1 \\ d_2 \\ \vdots \\ d_k \end{matrix} \right ]  
=
\left [  \begin{matrix} c_1 \\ c_2 \\ \vdots \\ c_m \end{matrix} \right ]
 \tag {2}
$$

即可得到各个编码块  $ c_1, c_2, \dots   , c_m$ 。


### 编码矩阵的产生
为了使系统在 $ n = m+k$ 个块中的任意 $m$ 个块失效后，我们都能够利用纠删码机制将其恢复，我们使用的纠删码必须满足 MDS 性质。
满足MDS的纠删码的编码矩阵需要满足下面的一个性质：
对于编码矩阵 $V$, 我们生成矩阵 

$$ U =  \left [  \begin{matrix} E \\ V \end{matrix} \right ] $$

其中$E$是$k \times k$ 的单位阵。
这样，当U矩阵删去任意$m$行时，剩下的$k \times k$的矩阵是可逆矩阵，我们就成该编码满足MDS性质。
我们使用了Vandermond 矩阵 

$$ \left  [  \begin {matrix} 
1 &  1 & \ldots &1 \\
1^2 &  2^2 & \ldots & k^2 \\
\vdots & \vdots & \ddots & \vdots\\
1^{m-1} &  2^{m-1} & \ldots & k^{m-1}
\end{matrix}  \right  ]   $$

### 纠删码编码例子
我们举一个简单的例子来具体说明上面描述的RS纠删码的编码过程。
为了简单，我们取 $w  = 4$. 有 3个数据块，有3个编码块。
那么我们需要产生 $3 \times 3 $的Vandermande矩阵


$$  V = \left  [ \begin {matrix} 
1^0 &  2^0  & 3^0 \\ 
1^1 &  2^2  & 3^1 \\ 
1^2 &  2^3  & 3^2 \\ 
\end{matrix}  \right  ] 
=
\left  [ \begin {matrix} 
1 &  1  & 1 \\ 
1 &  2  & 3 \\ 
1 &  4  & 5 \\ 
\end{matrix}  \right  ]   $$

上式中的幂次是伽罗瓦域上面的幂次， $3^2 = gfexp[gflog[3]+gflog[3] ] = gfexp[8] = 5$ 
我们设三个数据块 $d_1, d_2, d_3$ 分别等于 11, 3, 5
这样我们可以用下面的计算方法得到三个编码块 $c_1, c_2, c_3 $。

$$ c_1 = 1 \times d_1 + 1 \times d_2 + 1 \times d_3 =1 \times 11+ 1 \times 3+ 1 \times 5 =11+3+5 = 1011 \oplus 0011 \oplus 0101 = 1101 = 13 $$

$$ c_2 = 1 \times d_1 + 2 \times d_2 + 3 \times d_3 =1 \times 11+ 2 \times 3+ 3 \times 5 =11+6+15 = 1011 \oplus 0110 \oplus 1111 = 0010 = 7 $$

$$ c_1 = 1 \times d_1 + 4 \times d_2 + 5 \times d_3 =1 \times 11+ 4 \times 3+ 5 \times 5 =11+12+2 = 1011 \oplus 1100 \oplus 0010 = 0101 = 5 $$



##2.3 纠删码解码
解码时，我们任意选择 $k$  个存活的数据或编码块，将其组成 $x$.
然后，将矩阵 $U$中对应于 $x$中选择的块的行保留，其他行都删除，我们得到解码矩阵$V'$.
根据编码规则，我们如下等式，

$$ V' \times D = x \tag{3} $$

又因为我们选择编码矩阵时，编码矩阵满足MDS性质，即矩阵U的任意$k$ 行组成的 $k \times k $ 的矩阵都是可逆的，因此上面的矩阵 $V'$也是可逆的。
所以我们将$(3)$ 两边左乘 矩阵 $V'$ 的逆矩阵  $V'^{-1}$，我们得到

$$ D = x \times V'^{-1}$$

我们就恢复了原始数据。
然后利用编码规则再计算一遍编码数据即可恢复编码数据。

###纠删码解码举例
我们继续用上面的例子来说明上面描述的解码过程。
假设$d_1, d_3, c_1$ 丢失了，我们可以得到 

$$V'=\left  [ \begin {matrix} 
0 &  1  & 0 \\ 
1 &  2  & 3 \\ 
1 &  4  & 5 \\ 
\end{matrix}  \right  ]   $$

利用高斯消去法我们求$V'$ 的逆矩阵

$$  \left  [ \begin {matrix} 
0 &  1  & 0 & 1 &  0  & 0  \\ 
1 &  2  & 3 & 0 &  1  & 0  \\
1 &  4  & 5 & 0 &  0  & 1  \\
\end{matrix}  \right  ]   
=
\left  [ \begin {matrix} 
1 &  2  & 3 & 0 &  1  & 0  \\
0 &  1  & 0 & 1 &  0  & 0  \\ 
1 &  4  & 5 & 0 &  0  & 1  \\
\end{matrix}  \right  ]    $$

$$=
\left  [ \begin {matrix} 
1 &  2  & 3 & 0 &  1  & 0  \\
0 &  1  & 0 & 1 &  0  & 0  \\ 
0 &  6  & 6 & 0 &  1  & 1  \\
\end{matrix}  \right  ]   
=
\left  [ \begin {matrix} 
1 &  0  & 5 & 4 &  0  & 1  \\
0 &  1  & 0 & 1 &  0  & 0  \\ 
0 &  0  & 6 & 6 &  1  & 1  \\
\end{matrix}  \right  ]   $$

$$=
\left  [ \begin {matrix} 
1 &  0  & 5 & 4 &  0  & 1  \\
0 &  1  & 0 & 1 &  0  & 0  \\ 
0 &  0  & 1 & 1 &  7  & 7  \\
\end{matrix}  \right  ]   
=
\left  [ \begin {matrix} 
1 &  0  & 0 & 1 &  8  & 9  \\
0 &  1  & 0 & 1 &  0  & 0  \\ 
0 &  0  & 1 & 1 &  7  & 7  \\
\end{matrix}  \right  ]   $$

我们得到 $$V'^{-1} = \left  [ \begin {matrix} 
 1 &  8  & 9  \\
 1 &  0  & 0  \\ 
 1 &  7  & 7  \\
\end{matrix}  \right  ]   $$

接下来我们利用公式 $D=V'^{-1}  \times x$ , 来计算原始的数据
$$D=[d_1, d_2, d_3] ^T = V'^{-1} \times x =\left  [ \begin {matrix} 
 1 &  8  & 9  \\
 1 &  0  & 0  \\ 
 1 &  7  & 7  \\
\end{matrix}  \right  ]  \times  
\left  [ \begin {matrix} 
 3   \\
 2   \\ 
 5   \\
\end{matrix}  \right  ]$$

$$d_1 = 1 \times 3 + 8 \times 2+ 9 \times 5 = 3+3+11 = 0011 \oplus 0011 \oplus 1011 = 1011 = 11 $$

$$d_2 = 1 \times 3 + 0 \times 2+ 0 \times 5 = 3+0+0 = 0011 \oplus 0000 \oplus 0000 = 0011 = 3 $$

$$d_3 = 1 \times 3 + 7 \times 2+ 7 \times 5 = 3+14+8 = 0011 \oplus 1110 \oplus 1000 = 0101 = 5 $$ 

我们即恢复了原始数据。然后利用原始数据和编码矩阵再计算编码数据。


#3 加速纠删码计算相关研究

##3.1 利用CPU的SIMD指令加速
在实际使用的分布式存储系统中, 人们都会将字长 $ w $ 选的小一些, 这样可以保证伽罗瓦域上面的乘法的小一些.
但是当 $ w = 4$ ,或$ w = 8$时, 每次只对4位或8位进行计算就会显得整体计算速度很慢.
现代最新的X86　CPU 都有SIMD指令, 如SSE指令,每次能对128位的数据进行计算.
我们可以将128位分解为16个8位的数据,这时就可以对 16 个8 位的数据同时进行运算.
当$ w = 4 $ 时, 可以同时对 32 个元素进行运算. 
当$ w = 8 $ 时, 可以同时对 16 个元素进行运算. 
因为伽罗瓦域上面的两个元素的加法 就是 它们 的异或, 所以用SSE指令很容易同时对多个元素进行加法运算.
真正耗费时间的还是乘法运算, 我在下面描述一下如何用SIMD指令加速伽罗瓦域上面的乘法计算.
令$ y = 4$, A = 49 a5 83 69 0e f8 d6 83 1c 27 31 63 d7 41 8f 6b, 是32个4位数据的128位表示，我们下面计算 $ yA $, 即 $y$ 与 A中的每个4位元素的乘积。

当 $ w = 4 $时。

我们选择 $ y = 4 $

指令 | 数据
:---------------:| :---------------------------------------------: 
byte:			 | f  e  d  c  b  a  9  8  7  6  5  4  3  2  1  0
table1			 |09 0d 01 05 0a 0e 02 06 0f 0b 07 03 0c 08 04 00
table2			 |90 d0 10 50 a0 e0 20 60 f0 b0 70 30 c0 80 40 00
mask1			 |0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f
mask2			 |f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0
A				 |49 a5 83 69 0e f8 d6 83 1c 27 31 63 d7 41 8f 6b
l=and(A, mask1)	 |09 05 03 09 0e 08 06 03 0c 07 01 03 07 01 0f 0b
l=lookup(table1, l)	| 02 07 0c 02 0d 06 0b 0c 05 0f 04 0c 0f 04 09 0a
h=and(A, mask2)		|40 a0 80 60 00 f0 d0 80 10 20 30 60 d0 40 80 60
h=rs(h, 4)		 	|04 0a 08 06 00 0f 0d 08 01 02 03 06 0d 04 08 06
h=lookup(table2, h)	|30 e0 60 b0 00 90 10 60 40 80 c0 b0 10 30 60 b0
yA=xor(h, l)		| 32 e7 6c b2 0d 96 1b 6c 45 8f c4 bc 1f 34 69 ba

1.  因为 y=4， 所以在上面生成的乘法表中选择 $a=4$ 对应的那一行， 记为 table1
2. 将table1 右移 4 位，得到table2
3.   生成16个字节的每个字节高四位为0，低四位为1的mask1
4.   生成16个字节的每个字节高四位为1，低四位为0的mask2
5.   A为 32 个 四位数据组成的一个128位数据
6. and(a, b) 指令求 a 与 b 的按位与。 and(A, mask1) 将 A 中16个字节的每个字节的高四位变为0， 相当于将A中32个4位数据的奇数索引数据去掉，只保留偶数索引数据(从0开始)
7.   lookup(table1, l)用 l 做索引在table1中查找相应元素，并填入对应位置。如 l = 09 索引的table1表中的02，lookup指令执行之后，结果的最高字节位02。
8. and(A, mask2)将 A 中16个字节的每个字节的低四位变为0， 相当于将A中32个4位数据的偶数索引数据去掉，只保留奇数索引数据(从0开始)
9.   sr(h, 4) 将h 逻辑右移4位
10.   之后用 h 做索引在table2中进行查表，得到 y 与A中偶数索引数据的结果。
11.   最后将之前计算的A中奇数索引数据和偶数索引数据组装在一起，可以使用异或xor指令，即得到 yA的结果。

当 $ w = 8 $时，因为我们一次只能在16个元素的表中进行查找，所以我们没有办法一次查表就将两个元素的乘积查出来。
我们可以将8位的 a 分为高4位 $ a_h $ 和低四位的 $ a_l $, 这样利用 $ a_h $ 和 $ a_r $, 我们可以利用下面的公式求出a.

$$ a = ( a_ h << 4 ) + a_l $$

那么 y 乘以 a 可以写为如下公式：

$$ y \times a = y \times (a_h<<4)+y \times a_l$$

这样我们可以先用查表计算 $y(a_h<<4)$, 再利用一次查表计算出 $y a_l$, 然后再将结果相加即可，注意这里的加是伽罗瓦域上面的加法，即两个元素的异或。

我们选择 $ y = 4 $, 表1和表2的产生方法。

$$table1[i]  = y \times i , i \in [0, 15] $$

$$table1[i] = y \times (i << 4), i \in [0, 15] $$

指令 | 数据
--| -- 
byte			| 0f 0e 0d 0c 0b 0a 09 08 07 06 05 04 03 02 01 00
table1			| 3c 38 34 30 2c 28 24 20 1c 18 14 10 0c 08 04 00
table2			| e7 a7 67 27 fa ba 7a 3a dd 9d 5d 1d c0 80 40 00
mask1			| 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f
mask2			| f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0
A			 	| 49 a5 83 69 0e f8 d6 83 1c 27 31 63 d7 41 8f 6b
l=and(A, mask1)		| 09 05 03 09 0e 08 06 03 0c 07 01 03 07 01 0f 0b
l=lookup(table1, l)	| 24 14 0c 24 38 20 18 0c 30 1c 04 0c 1c 04 3c 2c
h=and(A, mask2)		| 40 a0 80 60 00 f0 d0 80 10 20 30 60 d0 40 80 60
h=rs(h, 4)		 |04 0a 08 06 00 0f 0d 08 01 02 03 06 0d 04 08 06
h=lookup(table2, h)	 |1d ba 3a 9d 00 e7 67 3a 40 80 c0 9d 67 1d 3a 9d
yA=xor(h, l)		| 39 ae 36 b9 38 c7 7f 36 70 9c c4 91 7b 19 06 b1

##3.2 利用GPU加速
因为纠删码的运算可以划分为很多 小的独立的计算任务，这种运算模式正好利用GPGPU同时并行处理很多计算的模式，因此可以用GPU来加速纠删码的计算。


###Towards Efficient Execution of Erasure Codes on Multicore Architectures
这篇论文的作者在论文中说Galois Field  $ GF(2^w) $ 上面的乘法计算开销很昂贵，因此他选择使用GPU加速 RS 的Cauchy 变体。
柯西RS与 RS 的主要不同是， 编码矩阵不使用Vandermande矩阵， 而是改为了柯西矩阵， 同时将柯西矩阵写为二进制形式，这样就可以将Galois Fields上面的乘法计算变为异或计算。

``` cuda
for j = 0 to  n-1  :
    for l = 0 to w - 1 :
        --------------------------------GPU kernel---
            for i = 0 to m-1 :
                for k = 0 to w - 1:
                    $　c_{i,k} := c_{i,k} \oplus v_{i,k,j,l} * d_{j,l}  $
          --------------------------------GPU kernel---

```

### 台湾国立交通大学 Yuan Shuai
使用NVIDIA的GPGPU加速RS纠删码的计算。
实现了  $ w = 8 $ 的字长。
Yuan主要在三方面对GPU计算RS纠删码进行加速：
####  1、加速伽罗瓦域上面的乘法
因为当 $ w = 8 $ 时， 乘法表共有53336个数据，空间开销比较大，因此他使用了对数和指数两个表的方法 计算伽罗瓦域上面的乘法，并且去除了模运算、条件分支。

#### 2 、加速矩阵乘运算
因为纠删码主要的计算时间都花在编码和解码过程中的矩阵相乘上面，因此利用GPU加速也主要是加速这个过程。
矩阵的相乘可以分解为很多独立的小的计算部分，因此很适合用GPU的大量的线程进行计算。
Yuan使用了Tiling 算法，并且用到了Word Alignment。（注：目前还没看懂整个算法）

#### 3、降低CPU与GPU之间的数据传输
因为使用GPU计算RS纠删码，在编码过程中需要将所有的数据块从Host Memory 拷贝到 GPU Memory， 在GPU中计算出编码块之后，还要将编码数据从GPU Memory拷贝回Host Memory，因此数据传输的开销很大。作者使用了GPU的CUDA 流，使GPU计算编码数据和CPU与GPU中间的数据传输并行，这样可以将数据传输的开销降到最低。

如上图，将数据传输与计算从串行改为并发

#4 我要做的工作
##4.1 进一步优化GPU加速

##4.2 ...


[^Pla97]: Note Correction to the 1997 Tutorial on Reed-Solomon Coding
[^Pla13]: Screaming Fast Galois Field Arithmetic Using Intel SIMD Instructions
[^Rom10]: towards efficient execution of erasure codes on multicore architectures
[^Yuan]: https://github.com/yszheda/GPU-RSCode/